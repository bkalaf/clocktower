*************
/home/bobby/clocktower/src/machines/AppShell.ts
*************
// src/machines/AppShell.ts

import { setup } from 'xstate';

export const machine = setup({
    types: {
        context: {} as { name: string; userId: string; currentRoomId: string },
        events: {} as
            | { type: 'LOGOUT' }
            | { type: 'LEAVE_ROOM' }
            | { type: 'LOGIN_SUCCESS' }
            | { type: 'ENTER_ROOM'; roomId: string }
    }
}).createMachine({
    context: {},
    id: 'AppShell',
    initial: 'unauthenticated',
    states: {
        unauthenticated: {
            on: {
                LOGIN_SUCCESS: {
                    target: 'lobby'
                }
            }
        },
        lobby: {
            on: {
                ENTER_ROOM: {
                    target: 'in_room',
                    description: '{ roomId: string }'
                },
                LOGOUT: {
                    target: 'unauthenticated'
                }
            }
        },
        in_room: {
            on: {
                LEAVE_ROOM: {
                    target: 'lobby'
                },
                LOGOUT: {
                    target: 'unauthenticated'
                }
            }
        }
    }
});

*************
/home/bobby/clocktower/src/machines/MatchMachine.ts
*************
// src/machines/MatchMachine.ts
import { assign, setup } from 'xstate';

export type NominationType = 'execution' | 'exile';
export type VoteChoice = 'yes' | 'no' | 'abstain';

type CurrentNomination = {
    nominatorId: string;
    nomineeId: string;
    nominationType: NominationType;
    openedAt: number;
};

type VoteRecord = {
    voterId: string;
    choice: VoteChoice;
    usedGhost?: boolean;
};

type VoteHistoryEntry = {
    day: number;
    nominationType: NominationType;
    nominatorId: string;
    nomineeId: string;
    votesFor: number;
    threshold: number;
    passed: boolean;
    votes: VoteRecord[];
    ts: number;
};

type OnTheBlockStatus = {
    nomineeId: string;
    votesFor: number;
    nominatorId: string;
};

type MatchContext = {
    phase: string;
    roomId: string;
    matchId: string;
    scriptId: string;
    subphase: string;
    dayNumber: number;
    playerSeatMap: Record<string, unknown>;
    stStateVersion: Record<string, unknown>;
    customScriptRoles: unknown[];
    publicStateVersion: number;
    storytellerUserIds: string;
    allowTravelers: boolean;
    acceptTravelers: boolean;
    travelerCountUsed: number;
    availableTravelers: unknown[];
    pendingTravelerRequests: unknown[];
    dayNominated: string[];
    dayNominators: string[];
    currentNomination?: CurrentNomination;
    currentVotes: Record<string, VoteChoice>;
    currentVoteGhostUsage: Record<string, boolean>;
    isAliveById: Record<string, boolean>;
    isTravelerById: Record<string, boolean>;
    ghostVoteAvailableById: Record<string, boolean>;
    onTheBlock?: OnTheBlockStatus;
    voteHistory: VoteHistoryEntry[];
};

type MatchEvent =
    | { type: 'DAWN' }
    | { type: 'DUSK' }
    | { type: 'CLOCKTOWER_GONG' }
    | { type: 'REVEAL_COMPLETE' }
    | { type: 'OPEN_NOMINATIONS' }
    | { type: 'CLOSE_NOMINATIONS' }
    | { type: 'GAME_OVER'; payload: { winner: string } }
    | { type: 'EXECUTION_OCCURRED' }
    | { type: 'ANNOUNCEMENTS_COMPLETE' }
    | { type: 'SETUP_COMPLETE' }
    | { type: 'TRAVELER_REQUESTED'; requestId: string; userId: string }
    | { type: 'DECIDE_TRAVELER'; requestId: string; decision: string; characterRole: string }
    | {
          type: 'NOMINATION_ATTEMPTED';
          payload: { nominatorId: string; nomineeId: string; nominationType: NominationType };
      }
    | { type: 'VOTE_CAST'; payload: { voterId: string; choice: VoteChoice } }
    | { type: 'VOTE_CLOSED' };

type GuardMeta = {
    context: MatchContext;
    event: MatchEvent;
};

const initialContext: MatchContext = {
    phase: 'setup',
    roomId: '',
    matchId: '',
    scriptId: '',
    subphase: 'day.dawn_announcements',
    dayNumber: 1,
    playerSeatMap: {},
    stStateVersion: {},
    customScriptRoles: [],
    publicStateVersion: 0,
    storytellerUserIds: '',
    allowTravelers: false,
    acceptTravelers: false,
    travelerCountUsed: 0,
    availableTravelers: [],
    pendingTravelerRequests: [],
    dayNominated: [],
    dayNominators: [],
    currentNomination: undefined,
    currentVotes: {},
    currentVoteGhostUsage: {},
    isAliveById: {},
    isTravelerById: {},
    ghostVoteAvailableById: {},
    onTheBlock: undefined,
    voteHistory: []
};

const canNominateGuard = ({ context, event }: GuardMeta) => {
    if (event.type !== 'NOMINATION_ATTEMPTED') return false;
    const { nominatorId } = event.payload;
    const isAlive = context.isAliveById[nominatorId] ?? false;
    const isTraveler = context.isTravelerById[nominatorId] ?? false;
    const alreadyNominated = context.dayNominators.includes(nominatorId);
    const hasActiveNomination = Boolean(context.currentNomination);
    return isAlive && !isTraveler && !alreadyNominated && !hasActiveNomination;
};

const canBeNominatedGuard = ({ context, event }: GuardMeta) => {
    if (event.type !== 'NOMINATION_ATTEMPTED') return false;
    const { nomineeId, nominationType } = event.payload;
    if (context.dayNominated.includes(nomineeId)) return false;
    const nomineeIsTraveler = context.isTravelerById[nomineeId] ?? false;
    const nomineeIsAlive = context.isAliveById[nomineeId] ?? false;
    if (nominationType === 'execution') {
        return nomineeIsAlive && !nomineeIsTraveler;
    }
    if (nominationType === 'exile') {
        return nomineeIsTraveler;
    }
    return false;
};

const canNominateAndBeNominatedGuard = (meta: GuardMeta) => canNominateGuard(meta) && canBeNominatedGuard(meta);

const canVoteGuard = ({ context, event }: GuardMeta) => {
    if (event.type !== 'VOTE_CAST') return false;
    if (!context.currentNomination) return false;
    const { voterId, choice } = event.payload;
    const isExecution = context.currentNomination.nominationType === 'execution';
    const isAlive = context.isAliveById[voterId] ?? false;
    if (isAlive) return true;
    if (!isExecution) return true;
    if (choice === 'abstain') return true;
    const hasGlobalGhost = context.ghostVoteAvailableById[voterId] !== false;
    const usedGhostAlready = Boolean(context.currentVoteGhostUsage[voterId]);
    return hasGlobalGhost || usedGhostAlready;
};

export const machine = setup({
    types: {
        context: {} as MatchContext,
        events: {} as MatchEvent
    },
    actions: {
        autoDenyNotAccepting: function ({ context, event }, params) {
            // Add your action code here
            // ...
        },
        enqueueRequest: function ({ context, event }, params) {
            // Add your action code here
            // ...
        },
        autoDenyIneligible: function ({ context, event }, params) {
            // Add your action code here
            // ...
        },
        approveTraveler: function ({ context, event }, params) {
            // Add your action code here
            // ...
        },
        resetDailyNominationLimits: assign((context) => ({
            dayNominated: [],
            dayNominators: [],
            currentNomination: undefined,
            currentVotes: {},
            currentVoteGhostUsage: {}
        })),
        startNomination: assign(({ context, event }) => {
            if (event.type !== 'NOMINATION_ATTEMPTED') return {};
            const { nominatorId, nomineeId, nominationType } = event.payload;
            const nextNominators =
                context.dayNominators.includes(nominatorId) ?
                    context.dayNominators
                :   [...context.dayNominators, nominatorId];
            const nextNominated =
                context.dayNominated.includes(nomineeId) ? context.dayNominated : [...context.dayNominated, nomineeId];
            return {
                dayNominators: nextNominators,
                dayNominated: nextNominated,
                currentNomination: {
                    nominatorId,
                    nomineeId,
                    nominationType,
                    openedAt: Date.now()
                },
                currentVotes: {},
                currentVoteGhostUsage: {}
            };
        }),
        recordVote: assign(({context, event}) => {
            if (event.type !== 'VOTE_CAST') return {};
            if (!context.currentNomination) return {};
            const { voterId, choice } = event.payload;
            const isExecution = context.currentNomination.nominationType === 'execution';
            const isAlive = context.isAliveById[voterId] ?? false;
            const isDead = !isAlive;
            const consumesGhostVote = isExecution && isDead && choice !== 'abstain';
            const updatedVotes = {
                ...context.currentVotes,
                [voterId]: choice
            };
            const updatedGhostUsage = { ...context.currentVoteGhostUsage };
            if (consumesGhostVote) {
                updatedGhostUsage[voterId] = true;
            }
            const assignments: Partial<MatchContext> = {
                currentVotes: updatedVotes,
                currentVoteGhostUsage: updatedGhostUsage
            };
            if (consumesGhostVote) {
                const alreadyUsed = Boolean(context.currentVoteGhostUsage[voterId]);
                const hasGhostAvailable = context.ghostVoteAvailableById[voterId] !== false;
                if (!alreadyUsed && hasGhostAvailable) {
                    assignments.ghostVoteAvailableById = {
                        ...context.ghostVoteAvailableById,
                        [voterId]: false
                    };
                }
            }
            return assignments;
        }),
        resolveNomination: assign(({context}) => {
            const nomination = context.currentNomination;
            if (!nomination) return {};
            const aliveNonTraveler = Object.entries(context.isAliveById).reduce((count, [id, alive]) => {
                if (!alive) return count;
                if (context.isTravelerById[id]) return count;
                return count + 1;
            }, 0);
            const threshold = Math.ceil(aliveNonTraveler / 2);
            const votes: VoteRecord[] = Object.entries(context.currentVotes).map(([voterId, choice]) => ({
                voterId,
                choice,
                ...(context.currentVoteGhostUsage[voterId] ? { usedGhost: true } : {})
            }));
            const votesFor = votes.filter((vote) => vote.choice === 'yes').length;
            const passed = votesFor >= threshold;
            const historyEntry: VoteHistoryEntry = {
                day: context.dayNumber,
                nominationType: nomination.nominationType,
                nominatorId: nomination.nominatorId,
                nomineeId: nomination.nomineeId,
                votesFor,
                threshold,
                passed,
                votes,
                ts: Date.now()
            };
            let updatedOnTheBlock = context.onTheBlock;
            if (passed && nomination.nominationType === 'execution') {
                if (!context.onTheBlock || votesFor > context.onTheBlock.votesFor) {
                    updatedOnTheBlock = {
                        nomineeId: nomination.nomineeId,
                        votesFor,
                        nominatorId: nomination.nominatorId
                    };
                }
            }
            return {
                voteHistory: [...context.voteHistory, historyEntry],
                onTheBlock: updatedOnTheBlock
            };
        }),
        clearNomination: assign(() => ({
            currentNomination: undefined,
            currentVotes: {},
            currentVoteGhostUsage: {}
        }))
    },
    guards: {
        isAllowingTravelers: function ({ context, event }, params) {
            // Add your guard code here
            return context.allowTravelers === true;
        },
        hasCapacity: function ({ context, event }) {
            // Add your guard condition here
            return true;
        },
        eligibleTraveler: function ({ context, event }) {
            // Add your guard condition here
            return true;
        },
        approved: function ({ context, event }) {
            // Add your guard condition here
            return true;
        },
        canNominate: canNominateGuard,
        canBeNominated: canBeNominatedGuard,
        canNominateAndBeNominated: canNominateAndBeNominatedGuard,
        canVote: canVoteGuard
    }
}).createMachine({
    context: initialContext,
    id: 'MatchMachine',
    initial: 'setup',
    states: {
        setup: {
            on: {
                SETUP_COMPLETE: {
                    target: 'in_progress'
                }
            }
        },
        in_progress: {
            initial: 'night',
            on: {
                GAME_OVER: {
                    target: 'reveal'
                }
            },
            states: {
                night: {
                    initial: 'resolve_first_night_order',
                    on: {
                        DAWN: {
                            target: '#MatchMachine.in_progress.day.dawn_announcements'
                        }
                    },
                    always: {
                        target: 'traveler_admission'
                    },
                    states: {
                        resolve_first_night_order: {},
                        resolve_night_order: {}
                    }
                },
                traveler_admission: {
                    type: 'parallel',
                    states: {
                        accepting: {
                            initial: 'routing',
                            states: {
                                routing: {
                                    always: [
                                        {
                                            target: 'capacity_available',
                                            guard: {
                                                type: 'hasCapacity'
                                            }
                                        },
                                        {
                                            target: 'limit_reached'
                                        }
                                    ]
                                },
                                capacity_available: {
                                    on: {
                                        TRAVELER_REQUESTED: [
                                            {
                                                target: 'capacity_available',
                                                actions: {
                                                    type: 'enqueueRequest'
                                                },
                                                guard: {
                                                    type: 'eligibleTraveler'
                                                }
                                            },
                                            {
                                                target: 'capacity_available',
                                                actions: {
                                                    type: 'autoDenyIneligible'
                                                }
                                            }
                                        ],
                                        DECIDE_TRAVELER: [
                                            {
                                                target: 'capacity_available',
                                                actions: {
                                                    type: 'approveTraveler'
                                                },
                                                guard: {
                                                    type: 'approved'
                                                }
                                            },
                                            {
                                                target: 'capacity_available'
                                            }
                                        ]
                                    },
                                    always: [
                                        {
                                            target: 'capacity_available',
                                            guard: {
                                                type: 'hasCapacity'
                                            }
                                        },
                                        {
                                            target: 'limit_reached'
                                        }
                                    ]
                                },
                                limit_reached: {
                                    always: {
                                        target: '#MatchMachine.in_progress.traveler_admission.not_accepting'
                                    }
                                }
                            }
                        },
                        not_accepting: {
                            on: {
                                TRAVELER_REQUESTED: {
                                    target: 'not_accepting',
                                    actions: {
                                        type: 'autoDenyNotAccepting',
                                        params: {
                                            requestId: 'string'
                                        }
                                    }
                                }
                            }
                        },
                        routing: {
                            always: [
                                {
                                    target: 'accepting',
                                    guard: {
                                        type: 'isAllowingTravelers'
                                    }
                                },
                                {
                                    target: 'not_accepting'
                                }
                            ]
                        }
                    }
                },
                day: {
                    initial: 'dawn_announcements',
                    on: {
                        DUSK: {
                            target: '#MatchMachine.in_progress.night.resolve_night_order'
                        }
                    },
                    states: {
                        dawn_announcements: {
                            entry: 'resetDailyNominationLimits',
                            on: {
                                EXECUTION_OCCURRED: {
                                    target: 'execution_resolution'
                                },
                                ANNOUNCEMENTS_COMPLETE: {
                                    target: 'discussions'
                                }
                            }
                        },
                        execution_resolution: {
                            always: {
                                target: '#MatchMachine.in_progress.night'
                            }
                        },
                        discussions: {
                            initial: 'private_conversations',
                            on: {
                                EXECUTION_OCCURRED: {
                                    target: 'execution_resolution'
                                }
                            },
                            states: {
                                private_conversations: {
                                    on: {
                                        CLOCKTOWER_GONG: {
                                            target: 'public_conversation'
                                        }
                                    }
                                },
                                public_conversation: {
                                    on: {
                                        OPEN_NOMINATIONS: {
                                            target: 'nominations'
                                        },
                                        EXECUTION_OCCURRED: {
                                            target: '#MatchMachine.in_progress.day.execution_resolution'
                                        }
                                    }
                                },
                                nominations: {
                                    initial: 'nominations_open',
                                    on: {
                                        CLOSE_NOMINATIONS: {
                                            target: '#MatchMachine.in_progress.day.discussions.public_conversation'
                                        },
                                        EXECUTION_OCCURRED: {
                                            target: '#MatchMachine.in_progress.day.execution_resolution'
                                        }
                                    },
                                    states: {
                                        nominations_open: {
                                            on: {
                                                NOMINATION_ATTEMPTED: {
                                                    target: 'vote_in_progress',
                                                    guard: {
                                                        type: 'canNominateAndBeNominated'
                                                    },
                                                    actions: {
                                                        type: 'startNomination'
                                                    }
                                                }
                                            }
                                        },
                                        vote_in_progress: {
                                            on: {
                                                VOTE_CAST: {
                                                    actions: {
                                                        type: 'recordVote'
                                                    },
                                                    guard: {
                                                        type: 'canVote'
                                                    }
                                                },
                                                VOTE_CLOSED: {
                                                    target: 'nomination_resolve'
                                                }
                                            }
                                        },
                                        nomination_resolve: {
                                            entry: ['resolveNomination', 'clearNomination'],
                                            always: {
                                                target: 'nominations_open'
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        reveal: {
            on: {
                REVEAL_COMPLETE: {
                    target: 'complete'
                }
            }
        },
        complete: {
            type: 'final'
        }
    }
});

*************
/home/bobby/clocktower/src/machines/RoomMachine.ts
*************
// src/machines/RoomMachine.ts

import { setup, createMachine } from 'xstate';

export const machine = setup({
    types: {
        context: {} as {
            speed: string;
            roomId: string;
            scriptId: string;
            hostUserId: string;
            maxPlayers: number;
            minPlayers: number;
            visibility: string;
            customScript: unknown[];
            readyByUserId: {};
            currentMatchId: string;
            storytellerMode: string;
            acceptingPlayers: string;
            connectedUserIds: unknown[];
            plannedStartTime: number;
            storytellerUserIds: unknown[];
            pendingSeatsInviteCount: number;
            beenNominated: unknown[];
            nominated: unknown[];
            voteHolders: unknown[];
            history: unknown[];
        },
        events: {} as
            | { type: 'OPEN_ROOM' }
            | { type: 'CLOSE_ROOM' }
            | { type: 'START_GAME' }
            | { type: 'MATCH_ENDED' }
            | { type: 'START_MATCH' }
            | { type: 'ARCHIVE_ROOM' }
            | { type: 'CONDITION_MET' }
            | { type: 'READY_CHANGED' }
            | { type: 'COOLDOWN_EXPIRED' }
            | { type: 'HOST_RECONNECTED' }
            | { type: 'HOST_DISCONNECTED' }
            | { type: 'HOST_GRACE_EXPIRED' }
    },
    actions: {
        startTimer: function ({ context, event }, params) {
            // Add your action code here
            // ...
        },
        cancelTimer: function ({ context, event }, params) {
            // Add your action code here
            // ...
        },
        reassignHost: function ({ context, event }, params) {
            // Add your action code here
            // ...
        },
        sendReminderPickStoryteller: function ({ context, event }, params) {
            // Add your action code here
            // ...
        }
    },
    actors: {
        MatchMachine: createMachine({
            /*
             * MatchMachine
             * https://stately.ai/registry/editor/5c3a42d7-840a-4cca-8642-37b14bdead8a?machine=65b9098f-063f-42b0-8940-fd108d8455f8
             */
        })
    },
    guards: {
        canStartMatch: function ({ context, event }) {
            // Add your guard condition here
            return true;
        },
        zeroConnected: function ({ context, event }) {
            // Add your guard condition here
            return true;
        },
        shouldRemindPickST: function ({ context, event }) {
            // Add your guard condition here
            return true;
        },
        allReady: function ({ context, event }) {
            // Add your guard condition here
            return true;
        }
    }
}).createMachine({
    context: {},
    id: 'RoomMachine',
    type: 'parallel',
    states: {
        hostContinuity: {
            initial: 'host_present',
            states: {
                host_present: {
                    on: {
                        HOST_DISCONNECTED: [
                            {
                                target: '#RoomMachine.roomStatus.archived',
                                guard: {
                                    type: 'zeroConnected'
                                },
                                description: 'connectedCount===0'
                            },
                            {
                                target: 'host_grace',
                                actions: {
                                    type: 'startTimer'
                                }
                            }
                        ]
                    }
                },
                host_grace: {
                    on: {
                        HOST_RECONNECTED: {
                            target: 'host_present',
                            actions: {
                                type: 'cancelTimer'
                            }
                        },
                        HOST_GRACE_EXPIRED: {
                            target: 'host_reassigned',
                            actions: {
                                type: 'reassignHost'
                            }
                        }
                    }
                },
                host_reassigned: {
                    always: {
                        target: 'host_present'
                    }
                }
            }
        },
        reminders: {
            initial: 'silent',
            states: {
                silent: {
                    on: {
                        CONDITION_MET: {
                            target: 'throttled',
                            actions: {
                                type: 'sendReminderPickStoryteller'
                            },
                            guard: {
                                type: 'shouldRemindPickST'
                            },
                            description: 'storytellerCount==0 and (minPlayers met or plannedStartTime passed)'
                        }
                    }
                },
                throttled: {
                    on: {
                        COOLDOWN_EXPIRED: {
                            target: 'silent'
                        }
                    }
                }
            }
        },
        roomStatus: {
            initial: 'open',
            states: {
                open: {
                    on: {
                        CLOSE_ROOM: {
                            target: 'closed'
                        },
                        START_MATCH: {
                            target: 'in_match'
                        }
                    }
                },
                closed: {
                    on: {
                        ARCHIVE_ROOM: {
                            target: 'archived'
                        },
                        OPEN_ROOM: {
                            target: 'open'
                        },
                        START_GAME: {
                            target: 'in_match',
                            guard: {
                                type: 'canStartMatch'
                            },
                            description:
                                'playerCount between minPlayers/maxPlayers AND storyteller selection rules:\n\nif storyteller mode is human: actor must be storyteller\n\nif storyteller mode is ai: actor must be host\n\nIf scriptId is set'
                        }
                    }
                },
                in_match: {
                    invoke: {
                        id: 'match',
                        input: {},
                        onDone: {
                            target: 'closed'
                        },
                        src: 'MatchMachine'
                    }
                },
                archived: {}
            }
        },
        readiness: {
            initial: 'collecting',
            states: {
                collecting: {
                    on: {
                        READY_CHANGED: {
                            target: 'all_ready',
                            guard: {
                                type: 'allReady'
                            }
                        }
                    }
                },
                all_ready: {}
            }
        }
    }
});
